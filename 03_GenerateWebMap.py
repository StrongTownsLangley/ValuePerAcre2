import json
import math
import os
import argparse
from collections import defaultdict
from typing import Dict, List, Any, Tuple, Optional

"""
Strong Towns Langley Value-Per-Acre Website Generator

This script processes the unified parcels GeoJSON file generated by CreateUnifiedFile.py and converted to WSG beforehand
and creates level-specific data files for visualization on a web map.

Python conversion of logic from https://github.com/StrongTownsLangley/ValuePerAcre
"""

def distance(lat1: float, lon1: float, lat2: float, lon2: float, unit: str = "K") -> float:
    """Calculate the distance between two points on the Earth's surface."""
    theta = lon1 - lon2
    dist = math.sin(deg2rad(lat1)) * math.sin(deg2rad(lat2)) + math.cos(deg2rad(lat1)) * math.cos(deg2rad(lat2)) * math.cos(deg2rad(theta))
    dist = math.acos(min(max(dist, -1.0), 1.0))  # Clamp value to avoid domain errors
    dist = rad2deg(dist)
    miles = dist * 60 * 1.1515
    
    unit = unit.upper()
    if unit == "K":
        return miles * 1.609344  # Convert to kilometers
    elif unit == "N":
        return miles * 0.8684    # Convert to nautical miles
    else:
        return miles             # Return miles

def deg2rad(deg: float) -> float:
    """Convert degrees to radians."""
    return deg * math.pi / 180.0

def rad2deg(rad: float) -> float:
    """Convert radians to degrees."""
    return rad * 180.0 / math.pi

def calculate_polygon_area(polygon: List[List[float]]) -> float:
    """
    Calculate the area of a polygon in acres using the Shoelace formula with local projection.
    Calibrated specifically for the Langley, BC area.
    
    Args:
        polygon: A list of points, where each point is [lon, lat]
    
    Returns:
        The area in acres
    """
    if len(polygon) < 3:
        return 0.0
    
    # Get the centroid of the polygon to use as reference point
    n = len(polygon) - 1  # Subtract 1 because first and last points are the same in a closed polygon
    if n <= 0:
        return 0.0
        
    avg_lat = sum(point[1] for point in polygon[:n]) / n
    avg_lon = sum(point[0] for point in polygon[:n]) / n
    
    # Constants for conversion at this latitude
    meters_per_lat = 111320  # meters per degree latitude (roughly constant)
    meters_per_lon = 111320 * math.cos(math.radians(avg_lat))  # meters per degree longitude
    
    # Convert to local X,Y coordinates in meters
    local_coords = []
    for lon, lat in polygon:
        x = (lon - avg_lon) * meters_per_lon
        y = (lat - avg_lat) * meters_per_lat
        local_coords.append((x, y))
    
    # Use Shoelace formula to calculate area
    area = 0.0
    for i in range(len(local_coords) - 1):
        x1, y1 = local_coords[i]
        x2, y2 = local_coords[i + 1]
        area += (x1 * y2) - (x2 * y1)
    
    # Take absolute value and convert to acres
    area_in_sq_meters = abs(area) / 2.0
    area_in_acres = area_in_sq_meters / 4046.86
    
    return area_in_acres

def find_parcel_bounds(geojson: Dict) -> Tuple[float, float, float, float]:
    """
    Find the minimum and maximum longitude and latitude in the GeoJSON.
    
    Args:
        geojson: The GeoJSON data
        
    Returns:
        Tuple of (min_longitude, max_longitude, min_latitude, max_latitude)
    """
    min_longitude = float('inf')
    max_longitude = float('-inf')
    min_latitude = float('inf')
    max_latitude = float('-inf')
    
    for feature in geojson['features']:
        geometry = feature['geometry']
        
        if geometry['type'] == 'Polygon':
            coordinates = geometry['coordinates'][0]  # Outer ring
            for coord in coordinates:
                lon, lat = coord
                min_longitude = min(min_longitude, lon)
                max_longitude = max(max_longitude, lon)
                min_latitude = min(min_latitude, lat)
                max_latitude = max(max_latitude, lat)
        elif geometry['type'] == 'MultiPolygon':
            for polygon in geometry['coordinates']:
                for coord in polygon[0]:  # Outer ring of each polygon
                    lon, lat = coord
                    min_longitude = min(min_longitude, lon)
                    max_longitude = max(max_longitude, lon)
                    min_latitude = min(min_latitude, lat)
                    max_latitude = max(max_latitude, lat)
    
    return min_longitude, max_longitude, min_latitude, max_latitude

def process_parcels_points_mode(unified_parcels: Dict, output_folder: str, block_size: float, levels: int) -> None:
    """
    Process parcels in points-based mode (centroids of parcels).
    
    Args:
        unified_parcels: The unified parcels GeoJSON
        output_folder: Where to save output files
        block_size: The size of blocks in meters
        levels: Number of levels to group blocks into
    """
    # Find bounds
    min_longitude, max_longitude, min_latitude, max_latitude = find_parcel_bounds(unified_parcels)
    
    print(f"Min Longitude: {min_longitude}")
    print(f"Max Longitude: {max_longitude}")
    print(f"Min Latitude: {min_latitude}")
    print(f"Max Latitude: {max_latitude}")
    
    # Calculate width and height in meters
    m_width = distance(min_latitude, min_longitude, max_latitude, min_longitude, "K") * 1000
    m_height = distance(min_latitude, min_longitude, min_latitude, max_longitude, "K") * 1000
    
    print(f"Width: {m_width} metres")
    print(f"Height: {m_height} metres")
    
    # Calculate blocks
    y_blocks = round(m_width / block_size)
    x_blocks = round(m_height / block_size)
    
    print(f"Width: {x_blocks} {block_size}m^2 blocks")
    print(f"Height: {y_blocks} {block_size}m^2 blocks")
    
    # Create specification array
    grouped_by_block_spec = {
        "min_longitude": min_longitude,
        "max_longitude": max_longitude,
        "min_latitude": min_latitude,
        "max_latitude": max_latitude,
        "width_in_metres": m_width,
        "height_in_metres": m_height,
        "size_of_block": block_size,
        "width_in_blocks": x_blocks,
        "height_in_blocks": y_blocks
    }
    
    # Calculate centroids and assign to blocks
    grouped_by_block = defaultdict(lambda: defaultdict(float))
    
    for feature in unified_parcels['features']:
        geometry = feature['geometry']
        properties = feature['properties']
        
        # Get taxable value
        tax_value = properties.get('TaxableValue', 0)
        if tax_value == 0:
            continue
            
        # Calculate centroid for the parcel
        if geometry['type'] == 'Polygon':
            # Simple average of coordinates for a quick centroid approximation
            coords = geometry['coordinates'][0]
            lon_sum = sum(p[0] for p in coords)
            lat_sum = sum(p[1] for p in coords)
            longitude = lon_sum / len(coords)
            latitude = lat_sum / len(coords)
        elif geometry['type'] == 'MultiPolygon':
            # Use the first polygon for simplicity
            coords = geometry['coordinates'][0][0]
            lon_sum = sum(p[0] for p in coords)
            lat_sum = sum(p[1] for p in coords)
            longitude = lon_sum / len(coords)
            latitude = lat_sum / len(coords)
        else:
            continue
            
        # Calculate block position
        y_block_pos = y_blocks - round(distance(min_latitude, min_longitude, latitude, min_longitude, "K") * 1000 / block_size)
        x_block_pos = round(distance(min_latitude, min_longitude, min_latitude, longitude, "K") * 1000 / block_size)
        
        # Add value to block
        grouped_by_block[x_block_pos][y_block_pos] += tax_value
    
    # Save data to files
    grouped_by_block_file = os.path.join(output_folder, "ValuesByBlockData.json")
    grouped_by_block_spec_file = os.path.join(output_folder, "ValuesByBlockSpec.json")
    
    print(f"Writing Value By Block Data JSON '{grouped_by_block_file}'...")
    print(f"Writing Value By Block Spec JSON '{grouped_by_block_spec_file}'...")
    
    with open(grouped_by_block_file, 'w', encoding='utf-8') as f:
        json.dump(grouped_by_block, f, indent=2)
    
    with open(grouped_by_block_spec_file, 'w', encoding='utf-8') as f:
        json.dump(grouped_by_block_spec, f, indent=2)
    
    # Find the best distribution of values into levels
    print("Searching for best distribution...")
    
    # Flatten the values and sort them
    all_values = []
    for x in grouped_by_block:
        for y in grouped_by_block[x]:
            all_values.append(grouped_by_block[x][y])
    
    all_values.sort(reverse=True)
    
    # Find the best block value for an even distribution
    best_distribution = None
    best_value = 0
    
    for i, test_block_value in enumerate(all_values):
        print(f"\rTesting value {i+1}/{len(all_values)} ({(i+1)/len(all_values)*100:.1f}%)", end="")
        
        # Calculate distribution for this test value
        distribution = [0] * levels
        
        for x in grouped_by_block:
            for y in grouped_by_block[x]:
                value = grouped_by_block[x][y]
                level = 0
                if value > 0:
                    level = min(math.floor(value / test_block_value * levels), levels - 1)
                distribution[int(level)] += 1
        
        # Check if this distribution is better
        if best_distribution is None or (max(distribution) - min(distribution) < max(best_distribution) - min(best_distribution)):
            best_distribution = distribution
            best_value = test_block_value
    
    print("\nBest value found. Generating level files...")
    
    # Calculate the size of one degree of latitude and longitude in meters
    deg_lat = 111320  # meters per degree at the equator
    deg_lon = 111320 * math.cos(math.pi * (min_latitude + max_latitude) / 360)  # meters per degree at this latitude
    
    # Create level files using the best distribution
    geo_json_array = []
    levels_info_array = []
    
    for level in range(levels):
        geo_json = {
            "type": "FeatureCollection",
            "features": [],
            "info": []
        }
        
        level_blocks = []
        
        # Find blocks for this level
        for x in grouped_by_block:
            for y in grouped_by_block[x]:
                value = grouped_by_block[x][y]
                if value == 0:
                    continue
                    
                block_level = min(math.floor(value / best_value * levels), levels - 1)
                
                if int(block_level) == level:
                    # Convert block coordinates to geographic coordinates
                    min_lon = min_longitude + (x * (block_size / deg_lon))
                    max_lon = min_longitude + ((x + 1) * (block_size / deg_lon))
                    min_lat = max_latitude - ((y + 1) * (block_size / deg_lat))
                    max_lat = max_latitude - (y * (block_size / deg_lat))
                    
                    level_blocks.append({
                        "min_lon": min_lon,
                        "max_lon": max_lon,
                        "min_lat": min_lat,
                        "max_lat": max_lat,
                        "value": value
                    })
        
        # If there are blocks for this level, add them to the GeoJSON
        if level_blocks:
            min_level_value = min(block["value"] for block in level_blocks)
            max_level_value = max(block["value"] for block in level_blocks)
            avg_level_value = sum(block["value"] for block in level_blocks) / len(level_blocks)
            
            # Add blocks to GeoJSON
            for block in level_blocks:
                feature = {
                    "type": "Feature",
                    "properties": {
                        "level": level,
                        "value": block["value"]
                    },
                    "geometry": {
                        "type": "Polygon",
                        "coordinates": [[
                            [block["min_lon"], block["min_lat"]],
                            [block["max_lon"], block["min_lat"]],
                            [block["max_lon"], block["max_lat"]],
                            [block["min_lon"], block["max_lat"]],
                            [block["min_lon"], block["min_lat"]]
                        ]]
                    }
                }
                geo_json["features"].append(feature)
            
            # Add level info
            info = {
                "level": level,
                "minLevelBlockValue": min_level_value,
                "maxLevelBlockValue": max_level_value,
                "avgLevelBlockValue": avg_level_value,
                "numLevelBlockValue": len(level_blocks)
            }
            geo_json["info"].append(info)
            levels_info_array.append(info)
            
            # Save level file
            level_file = os.path.join(output_folder, f"level_{level}.json")
            print(f"Writing Level JSON '{level_file}' file...")
            with open(level_file, 'w', encoding='utf-8') as f:
                json.dump(geo_json, f, indent=2)
            
            geo_json_array.append(geo_json)
    
    # Save level info file
    level_info_file = os.path.join(output_folder, "level_info.json")
    print(f"Writing Level Info JSON '{level_info_file}' file...")
    with open(level_info_file, 'w', encoding='utf-8') as f:
        json.dump(levels_info_array, f, indent=2)
    
    # Generate HTML files
    generate_html_files(min_latitude, max_latitude, min_longitude, max_longitude, levels, geo_json_array, output_folder)

def process_parcels_polygon_mode(unified_parcels: Dict, output_folder: str, levels: int) -> None:
    """
    Process parcels in polygon-based mode (using the actual parcel geometries).
    
    Args:
        unified_parcels: The unified parcels GeoJSON
        output_folder: Where to save output files
        levels: Number of levels to group blocks into
    """
    print("Processing parcels in polygon-based mode...")
    
    # Create Property objects with calculated value per acre
    properties = []
    
    for feature in unified_parcels['features']:
        pid = feature.get("id", "")
        geometry = feature['geometry']
        orig_properties = feature['properties']
        
        taxable_value = orig_properties.get('TaxableValue', 0)
        
        if taxable_value == 0:
            continue
            
        # Calculate area
        total_area = 0
        polygons = []
        
        if geometry['type'] == 'Polygon':
            coords = geometry['coordinates'][0]
            polygons.append(coords)
            total_area += calculate_polygon_area(coords)
        elif geometry['type'] == 'MultiPolygon':
            for polygon in geometry['coordinates']:
                coords = polygon[0]
                polygons.append(coords)
                total_area += calculate_polygon_area(coords)
        
        if total_area == 0:
            continue
            
        # Calculate value per acre
        value_per_acre = taxable_value / total_area
        
        # Calculate additional area measurements
        size_acres = total_area
        size_sqft = total_area * 43560  # 1 acre = 43,560 square feet
        size_sqm = total_area * 4046.86  # 1 acre = 4,046.86 square meters
        
        # Create a copy of original feature to preserve all properties
        new_feature = {
            "type": "Feature",
            "id": pid,
            "geometry": geometry,
            "properties": orig_properties.copy()  # Keep all original properties
        }
        
        # Add value_per_acre and size information to properties
        new_feature["properties"]["value_per_acre"] = round(value_per_acre, 2)
        new_feature["properties"]["size_acres"] = round(size_acres, 2)
        new_feature["properties"]["size_sqft"] = round(size_sqft, 2)
        new_feature["properties"]["size_sqm"] = round(size_sqm, 2)
        
        # Also add a formatted property address
        address_parts = []
        if "HOUSE" in orig_properties and orig_properties["HOUSE"]:
            address_parts.append(str(orig_properties["HOUSE"]))
        if "STREET" in orig_properties and orig_properties["STREET"]:
            address_parts.append(str(orig_properties["STREET"]))
        if "UNIT" in orig_properties and orig_properties["UNIT"]:
            address_parts.append(f"Unit {orig_properties['UNIT']}")
            
        new_feature["properties"]["formatted_address"] = " ".join(address_parts)
        
        properties.append({
            "pid": pid,
            "feature": new_feature,
            "polygons": polygons,
            "value": taxable_value,
            "total_area": total_area,
            "value_per_acre": value_per_acre,
            "level": None
        })
        
    # Rest of the function remains the same...
    # Sort properties by value per acre and assign levels
    properties.sort(key=lambda p: p["value_per_acre"])
    
    items_per_level = len(properties) // levels
    remainder = len(properties) % levels
    
    current_index = 0
    for level in range(levels):
        items_in_this_level = items_per_level + (1 if level < remainder else 0)
        
        for i in range(items_in_this_level):
            if current_index < len(properties):
                properties[current_index]["level"] = level
                properties[current_index]["feature"]["properties"]["level"] = level
                current_index += 1
    
    # Group properties by level
    grouped_pids = defaultdict(list)
    for prop in properties:
        if prop["level"] is not None:
            grouped_pids[prop["level"]].append(prop)
    
    # Generate level files
    geo_json_array = []
    levels_info_array = []
    
    for level, level_props in grouped_pids.items():
        geo_json = {
            "type": "FeatureCollection",
            "features": [],
            "info": []
        }
        
        # Calculate level stats
        min_level_value = min(p["value_per_acre"] for p in level_props)
        max_level_value = max(p["value_per_acre"] for p in level_props)
        avg_level_value = sum(p["value_per_acre"] for p in level_props) / len(level_props)
        
        # Add features to GeoJSON - now keeping original properties plus additional ones
        for prop in level_props:
            geo_json["features"].append(prop["feature"])
        
        # Add level info
        info = {
            "level": level,
            "minLevelBlockValue": min_level_value,
            "maxLevelBlockValue": max_level_value,
            "avgLevelBlockValue": avg_level_value,
            "numLevelBlockValue": len(level_props)
        }
        geo_json["info"].append(info)
        levels_info_array.append(info)
        
        # Save level file
        level_file = os.path.join(output_folder, f"level_{level}.json")
        print(f"Writing Level JSON '{level_file}' file...")
        with open(level_file, 'w', encoding='utf-8') as f:
            json.dump(geo_json, f, indent=2)
        
        geo_json_array.append(geo_json)
    
    # Save level info file
    level_info_file = os.path.join(output_folder, "level_info.json")
    print(f"Writing Level Info JSON '{level_info_file}' file...")
    with open(level_info_file, 'w', encoding='utf-8') as f:
        json.dump(levels_info_array, f, indent=2)
    
    # Find bounds for map
    min_longitude, max_longitude, min_latitude, max_latitude = find_parcel_bounds(unified_parcels)
    
    # Generate HTML files
    generate_html_files(min_latitude, max_latitude, min_longitude, max_longitude, levels, geo_json_array, output_folder)
    
def generate_html_files(min_latitude: float, max_latitude: float, min_longitude: float, max_longitude: float, 
                        levels: int, geo_json_array: List, output_folder: str) -> None:
    """
    Generate HTML files for web visualization.
    
    Args:
        min_latitude, max_latitude, min_longitude, max_longitude: Bounds for the map
        levels: Number of levels
        geo_json_array: Array of GeoJSON data for each level
        output_folder: Where to save output files
    """
    print("Generating HTML files...")
    
    # Calculate average latitude and longitude for map center
    avg_lat = (min_latitude + max_latitude) / 2
    avg_lon = (min_longitude + max_longitude) / 2
    
    # Read template file
    try:
        with open("vpa.template.html", 'r', encoding='utf-8') as f:
            template = f.read()
    except FileNotFoundError:
        print("Warning: vpa.template.html not found. Using built-in template.")
        template = """<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Value Per Acre Overlay</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <style>
        #map {
            height: 100vh;
        }
        .popup-content {
            min-width: 200px;
        }
        .property-info {
            margin-bottom: 5px;
        }
        .property-label {
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script>
        var map = L.map('map').setView([{AVGLAT}, {AVGLON}], 12);

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
        }).addTo(map);

        // Load GeoJSON files for each tax level
        var numLevels = {LEVELS};
        var taxLevels = [];
        
        // Format currency with dollar sign and commas
        function formatCurrency(value) {
            return '$' + parseFloat(value).toLocaleString('en-US', {
                minimumFractionDigits: 2,
                maximumFractionDigits: 2
            });
        }
        
        // Create popup content for property information
        function createPopupContent(properties) {
            var content = '<div class="popup-content">';
            
            if (properties.formatted_address) {
                content += '<div class="property-info"><span class="property-label">Address:</span> ' + properties.formatted_address + '</div>';
            }
            
            if (properties.FOLIO || properties.id) {
                var pid = properties.FOLIO || properties.id || 'N/A';
                content += '<div class="property-info"><span class="property-label">PID:</span> ' + pid + '</div>';
            }
            
            // Show the actual assessed value if available
            if (properties.AssessedValue) {
                content += '<div class="property-info"><span class="property-label">Assessed Value:</span> ' + 
                    formatCurrency(properties.AssessedValue) + '</div>';
            }
            
            // Show property tax as the taxable value
            if (properties.TaxableValue) {
                content += '<div class="property-info"><span class="property-label">Estimated Property Taxes Paid (excluding utilities):</span> ' + 
                    formatCurrency(properties.TaxableValue) + '</div>';
            }
            
            if (properties.value_per_acre) {
                content += '<div class="property-info"><span class="property-label">Value per Acre:</span> ' + 
                    formatCurrency(properties.value_per_acre) + '/acre</div>';
            }
            
            content += '</div>';
            return content;
        }
        
        for (var i = 0; i < numLevels; i++) {
            var taxLevel = L.geoJSON(null, {
                style: function(feature) {
                    var taxLevel = feature.properties.level;
                    var hue = (1 - (taxLevel / numLevels)) * 240; // Interpolate hue from blue (240) to red (0)
                    return {
                        fillColor: 'hsl(' + hue + ', 100%, 50%)',
                        weight: 0.5,
                        opacity: 0.45,
                        color: 'hsl(' + hue + ', 100%, 50%)',
                        fillOpacity: 0.45
                    };
                },
                onEachFeature: function(feature, layer) {
                    // Create popup with property info
                    var popupContent = createPopupContent(feature.properties);
                    layer.bindPopup(popupContent);
                    
                    // Add hover effect
                    layer.on('mouseover', function() {
                        this.setStyle({
                            weight: 2,
                            opacity: 0.7,
                            fillOpacity: 0.7
                        });
                    });
                    
                    layer.on('mouseout', function() {
                        this.setStyle({
                            weight: 0.5,
                            opacity: 0.45,
                            fillOpacity: 0.45
                        });
                    });
                }
            });
            taxLevels.push(taxLevel);
        }

        {DATALIST}

        for (var i = 0; i < numLevels; i++) {
            taxLevels[i].addTo(map);
        }

    </script>
</body>
</html>
"""
    
    # Replace template variables
    template = template.replace("{AVGLAT}", str(avg_lat))
    template = template.replace("{AVGLON}", str(avg_lon))
    template = template.replace("{LEVELS}", str(levels))
    
    # Create static version (with embedded data)
    geo_json_string = ""
    for i, geo_json in enumerate(geo_json_array):
        geo_json_string += f"taxLevels[{i}].addData({json.dumps(geo_json)}); \r\n"
    
    website_static = template.replace("{DATALIST}", geo_json_string)
    
    # Create dynamic version (loads data from files)
    website_dynamic = template.replace("{DATALIST}", """
for (var i = 0; i < numLevels; i++) {
    fetch('level_' + i + '.json')
        .then(response => response.json())
        .then(data => {
            // Find the level from the first feature or the info
            var level = 0;
            if (data.features.length > 0 && data.features[0].properties.level !== undefined) {
                level = data.features[0].properties.level;
            } else if (data.info.length > 0 && data.info[0].level !== undefined) {
                level = data.info[0].level;
            }
            taxLevels[level].addData(data);
        })
        .catch(error => console.error('Error loading GeoJSON file:', error));
}
""")
    
    # Save HTML files
    website_static_file = os.path.join(output_folder, "website.static.html")
    website_dynamic_file = os.path.join(output_folder, "website.dynamic.html")
    
    print(f"Writing Static Website Heatmap '{website_static_file}' file...")
    with open(website_static_file, 'w', encoding='utf-8') as f:
        f.write(website_static)
    
    print(f"Writing Dynamic Website Heatmap '{website_dynamic_file}' file...")
    with open(website_dynamic_file, 'w', encoding='utf-8') as f:
        f.write(website_dynamic)

def main():
    """Main function to process command line arguments and run the program."""
    parser = argparse.ArgumentParser(description="Strong Towns Langley Value-Per-Acre Website Generator")
    
    parser.add_argument("--input", "-i", required=True, help="Input GeoJSON file (unified parcels)")
    parser.add_argument("--output-folder", "-o", default="json", help="Output folder for generated files")
    parser.add_argument("--levels", "-l", type=int, default=50, help="Number of levels to group data into")
    parser.add_argument("--block-size", "-b", type=float, default=100.0, help="Size of blocks in meters (for points mode)")
    parser.add_argument("--mode", "-m", choices=["points", "polygons"], default="polygons", 
                      help="Processing mode: 'points' uses centroids, 'polygons' uses actual parcel shapes")
    
    args = parser.parse_args()
    
    print("Strong Towns Langley Value-Per-Acre Website Generator")
    print("https://github.com/StrongTownsLangley/ValuePerAcre")
    print("---------------------------------------------------")
    
    # Create output folder if it doesn't exist
    if not os.path.exists(args.output_folder):
        os.makedirs(args.output_folder)
        print(f"Created output folder: {args.output_folder}")
    
    # Load unified parcels file
    print(f"Loading unified parcels from: {args.input}")
    try:
        with open(args.input, 'r', encoding='utf-8') as f:
            unified_parcels = json.load(f)
    except Exception as e:
        print(f"Error loading input file: {e}")
        return
    
    print(f"Processing {len(unified_parcels['features'])} parcels")
    
    # Process parcels based on mode
    if args.mode == "points":
        process_parcels_points_mode(unified_parcels, args.output_folder, args.block_size, args.levels)
    else:
        process_parcels_polygon_mode(unified_parcels, args.output_folder, args.levels)
    
    print("Processing complete!")

if __name__ == "__main__":
    main()